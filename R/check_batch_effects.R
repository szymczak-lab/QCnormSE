
#' Check for batch effects
#'
#' Pairwise associations between each of the first three components of a MDS or
#' PCA analysis and defined phenotype variables is tested using F tests in a
#' linear model. P-values are visualized in a heatmap (called prince plot in
#' the R package swamp).
#'
#' @param se
#' \code{\link[SummarizedExperiment]{RangedSummarizedExperiment-class}}
#' object
#' @param col.test Character or integer vector. Column(s) in colData() with
#' phenotype information to be tested.
#' @param res.pca List. Output of \code{\link{calculate_mds_pca}}.
#'
#' @return List with the following components:
#' \itemize{
#' \item pval: Matrix with P-values between phenotype variables in rows and
#' components in columns
#' \item plot: Heatmap as \code{\link[ComplexHeatmap]{Heatmap-class}} object
#' }
#'
#' @importFrom ComplexHeatmap Heatmap
#' @importFrom viridis magma
#' @importFrom grid gpar
#' @export
#'
#' @examples
#' data("se.gene")
#'
#' res.pca = calculate_mds_pca(se = se.gene,
#'                             method = "pca")
#'
#' col.test = c("Age.of.patient",
#'              "Body.surface.area",
#'              "Duration.of.psoriasis",
#'              "Induration",
#'              "Overall.erythema",
#'              "Patient.identifyier",
#'              "Scaling",
#'              "Sex",
#'              "scan.date")
#'
#' check_batch_effects(se = se.gene,
#'                     res.pca = res.pca,
#'                     col.test = col.test)

check_batch_effects <- function(se,
                                res.pca,
                                col.test = NULL) {

    pheno = colData(se)
    if (!is.null(col.test)) {
        if (!all(col.test %in% colnames(colData(se)))) {
            stop("not all col.test variables available in colData!")
        }
        pheno = pheno[, col.test, drop = FALSE]
    }
    pheno = pheno[, sort(colnames(pheno)), drop = FALSE]
    scores = res.pca$scores

    ## F statistic of linear regression for each PC and phenotype variable
    pval = matrix(ncol = ncol(scores),
                  nrow = ncol(pheno),
                  dimnames = list(colnames(pheno),
                                  colnames(scores)))
    for (i in seq_len(nrow(pval))) {
        for (j in seq_len(ncol(pval))) {
            if (length(unique(na.omit(pheno[, i]))) < 2) {
                warning(paste0("only one level found in ",
                              colnames(pheno)[i], "!"))
            } else {
                fit = lm(scores[, j] ~ pheno[, i])
                s = summary(fit)
                pval[i, j] = pf(q = s$fstatistic[1],
                                df1 = s$fstatistic[2],
                                df2 = s$fstatistic[3],
                                lower.tail = FALSE)
            }
        }
    }

    ## remove rows with NA
    pval = na.omit(pval)
    if (nrow(pval) == 0) {
        stop("no variables with P-values!")
    }

    ## heatmap
    breaks = c(0, 10^-4, 10^-3, 10^-2, 0.05, 1)

    pval.cat = apply(pval, c(1, 2), function(x) {
        cut(x, breaks = breaks)
    })

#    col = c("lightyellow", rev(heat.colors(4)))
    col = c("white", "yellow", "orange", "red", "darkred")
    names(col) = c("(0.05,1]",
                   "(0.01,0.05]",
                   "(0.001,0.01]",
                   "(0.0001,0.001]",
                   "(0,0.0001]")
    hm = Heatmap(pval.cat,
                 rect_gp = gpar(col = "black"),
                 name = "P-value",
                 col = col,
                 cluster_rows = FALSE,
                 cluster_columns = FALSE,
                 heatmap_legend_param = list(border = "black"),
                 row_names_side = "left",
                 column_names_side = "top",
                 column_names_rot = 0)
    #print(hm)

    return(list(pval = pval,
                plot = hm))
}


#' Define batches based on scan date
#'
#' Groups samples into batches based on scan date. Samples run within a short
#' time interval can be defined to belong to the same batch.
#'
#' @param se \code{\link[SummarizedExperiment]{RangedSummarizedExperiment-class}}
#' object
#' @param col.scan.date Character or Integer. Column in colData() with scan
#' dates (default: scan.date as generated by the function
#' \code{\link{extract_scan_date}}.
#' @param diff.ignore Numeric. Time difference (in days) defined as negligible
#' (default: 1).
#'
#' @return \code{\link[SummarizedExperiment]{RangedSummarizedExperiment-class}}
#' object with batch information in additional column in colData()
#'
#' @export
#'
#' @examples
#' data("se.gene")
#' se.gene = define_batches(se = se.gene,
#'                          col.scan.date = "scan.date")

define_batches <- function(se,
                           col.scan.date = "scan.date",
                           diff.ignore = 1) {

    if (!(col.scan.date %in% colnames(colData(se)))) {
        stop(paste("column", col.scan.date, "not available in column data!"))
    }
    scan.date = colData(se)[, col.scan.date]
    names(scan.date) = colnames(se)
    scan.date = sort(scan.date)
    diff = c(0, as.numeric(diff(scan.date)))
    diff[diff == diff.ignore] = 0
    batch = as.numeric(as.factor(cumsum(diff)))
    names(batch) = names(scan.date)
    se$batch = batch[colnames(se)]
    return(se)
}


